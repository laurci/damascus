mod client;
mod serialization;
mod types;
mod utils;

use crate::aat::{AAT, FieldType};
use crate::generate::writer::CodeWriter;
use anyhow::Result;

pub struct TypeScriptGenerator {
    writer: CodeWriter,
}

impl TypeScriptGenerator {
    pub fn new() -> Self {
        Self {
            writer: CodeWriter::new(),
        }
    }

    pub fn generate(aat: &AAT) -> Result<String> {
        let mut generator = Self::new();
        generator.generate_client(aat)?;
        Ok(generator.writer.into_string())
    }

    fn generate_client(&mut self, aat: &AAT) -> Result<()> {
        // Generate header
        self.writer.line("// Generated by Damascus");
        self.writer.line("// Do not edit this file directly");
        self.writer.empty_line();

        // Generate types
        for named_type in &aat.types {
            types::generate_type(&mut self.writer, named_type)?;
            self.writer.empty_line();
        }

        // Generate WebSocketStream base class if needed
        if self.needs_websocket_stream(aat) {
            self.generate_websocket_stream_class()?;
            self.writer.empty_line();
        }

        // Generate serializers and deserializers
        for named_type in &aat.types {
            serialization::generate_serializer(&mut self.writer, named_type)?;
            self.writer.empty_line();
            serialization::generate_deserializer(&mut self.writer, named_type)?;
            self.writer.empty_line();
        }

        // Generate client class for each service
        for service in &aat.services {
            client::generate_service(&mut self.writer, service)?;
            self.writer.empty_line();
        }

        // Generate top-level ApiClient
        client::generate_api_client(&mut self.writer, aat)?;
        self.writer.empty_line();

        Ok(())
    }

    fn needs_websocket_stream(&self, aat: &AAT) -> bool {
        use crate::aat::Upgrade;

        for service in &aat.services {
            for endpoint in &service.endpoints {
                if matches!(endpoint.upgrade, Some(Upgrade::Ws)) {
                    return true;
                }
                if self.field_type_has_stream(&endpoint.response) {
                    return true;
                }
            }
        }
        false
    }

    fn field_type_has_stream(&self, field_type: &FieldType) -> bool {
        match field_type {
            FieldType::Stream(_) => true,
            FieldType::Optional(inner) | FieldType::List(inner) | FieldType::Map(inner) => {
                self.field_type_has_stream(inner)
            }
            FieldType::Tuple(types) | FieldType::Intersection(types) => {
                types.iter().any(|t| self.field_type_has_stream(t))
            }
            _ => false,
        }
    }

    fn generate_websocket_stream_class(&mut self) -> Result<()> {
        self.writer.block("export class WebSocketStream<T> {", "}", |w| {
            w.line("private ws: WebSocket | null = null;");
            w.line("private messageHandlers: Set<(data: T) => void> = new Set();");
            w.line("private errorHandlers: Set<(error: Error) => void> = new Set();");
            w.line("private closeHandlers: Set<() => void> = new Set();");
            w.empty_line();

            w.block("constructor(", ") {}", |w| {
                w.line("private url: string,");
                w.line("private deserialize: (data: any) => T,");
                w.line("private headers: Record<string, string> | undefined,");
                w.line("private WebSocketImpl: typeof WebSocket");
            });
            w.empty_line();

            w.block("async connect(): Promise<void> {", "}", |w| {
                w.block("return new Promise((resolve, reject) => {", "});", |w| {
                    w.line("const wsUrl = this.url.replace(/^http/, 'ws');");
                    w.line("this.ws = new this.WebSocketImpl(wsUrl);");
                    w.empty_line();

                    w.block("this.ws.onopen = () => {", "};", |w| {
                        w.line("resolve();");
                    });
                    w.empty_line();

                    w.block("this.ws.onmessage = (event) => {", "};", |w| {
                        w.block("try {", "} catch (error) {", |w| {
                            w.line("const data = JSON.parse(event.data);");
                            w.line("const deserialized = this.deserialize(data);");
                            w.line("this.messageHandlers.forEach(handler => handler(deserialized));");
                        });
                        w.line("this.errorHandlers.forEach(handler => handler(error as Error));");
                        w.line("}");
                    });
                    w.empty_line();

                    w.block("this.ws.onerror = (event) => {", "};", |w| {
                        w.line("const error = new Error('WebSocket error');");
                        w.line("this.errorHandlers.forEach(handler => handler(error));");
                        w.line("reject(error);");
                    });
                    w.empty_line();

                    w.block("this.ws.onclose = () => {", "};", |w| {
                        w.line("this.closeHandlers.forEach(handler => handler());");
                    });
                });
            });
            w.empty_line();

            w.block("onMessage(handler: (data: T) => void): () => void {", "}", |w| {
                w.line("this.messageHandlers.add(handler);");
                w.block("return () => {", "};", |w| {
                    w.line("this.messageHandlers.delete(handler);");
                });
            });
            w.empty_line();

            w.block("onError(handler: (error: Error) => void): () => void {", "}", |w| {
                w.line("this.errorHandlers.add(handler);");
                w.block("return () => {", "};", |w| {
                    w.line("this.errorHandlers.delete(handler);");
                });
            });
            w.empty_line();

            w.block("onClose(handler: () => void): () => void {", "}", |w| {
                w.line("this.closeHandlers.add(handler);");
                w.block("return () => {", "};", |w| {
                    w.line("this.closeHandlers.delete(handler);");
                });
            });
            w.empty_line();

            w.block("close(): void {", "}", |w| {
                w.block("if (this.ws) {", "}", |w| {
                    w.line("this.ws.close();");
                    w.line("this.ws = null;");
                });
            });
        });
        Ok(())
    }
}
